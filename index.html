<!DOCTYPE html>
<html>
  <head>
    <title>MultiVirusConsensus-Viz</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />
    <style>
      body {
        min-height: 100vh;
      }

      #use-example-data {
        transition: background-color 0.25s;
      }
    </style>
  </head>
  <body class="d-flex flex-column justify-content-between align-items-center">
    <div id="main-content">
      <h1 class="mt-5 mb-4 w-100 text-center">MultiVirusConsensus-Viz</h1>
      <p>
        Visualize position counts & coverage of
        <a href="https://github.com/niemasd/MultiVirusConsensus" target="_blank">MultiVirusConsensus</a> output. Browser-side & secure, no data is
        uploaded.
      </p>
      <div class="w-100 mt-5 d-flex justify-content-center flex-column" id="input-container">
        <label for="input-folder" class="btn btn-primary">Select MultiVirusConsensus Output Folder</label>
        <input type="file" id="input-folder" class="form-control d-none" webkitdirectory multiple />
      </div>
      <button id="use-example-data" class="btn btn-warning mt-3 w-100">Load Example Data</button>
      <h6 id="selected-folder-info" class="mt-3 text-center d-none">Currently selected folder: <span id="selected-folder"></span></h6>

      <div id="coverage-container" class="d-none">
        <h5 class="mt-5">Coverage Window</h5>
        <div class="d-flex">
          <div class="w-50 pe-3">
            <label for="coverage-window-start" class="mt-2">Start</label>
            <input type="number" id="coverage-window-start" class="form-control" value="0" min="0" />
          </div>
          <div class="w-50 ps-3">
            <label for="coverage-window-end" class="mt-2">End</label>
            <input type="number" id="coverage-window-end" class="form-control" value="1000" min="0" />
          </div>
        </div>
        <div class="w-100 d-flex flex-column align-items-center">
          <button id="update-coverage-window" class="btn btn-primary mt-3 w-100">Update</button>
          <button id="toggle-all-window-graphs" class="btn btn-outline-primary mt-3 w-100">Toggle All Window Coverage Graphs</button>
        </div>
      </div>
    </div>

    <div id="viz-container"></div>

    <footer id="footer" class="mt-5 mb-4">
      <h5>Future Features (Ranked by Estimated Priority)</h5>
      <ol>
        <li>#! Export graphs as PNG and all graphs at once (zip)</li>
        <li>#! Test 40 genomes & add lazy loading (load-out?) feature</li>
        <li>#! Re-arrangeable graph with sidebar up-down buttons</li>
        <li>#! Support compressed output folders (zip, tar.gz)</li>
        <li>Optimize performance</li>
        <li>Interactive Graphs</li>
        <li>Should x-axis be same across all graphs, even if some genomes don't have those position counts?</li>
        <li>Same y-axis across all graphs?</li>
        <li>Auto-hide certain outputs?</li>
        <li>Add folder validation?</li>
        <li>Make offline-able?</li>
      </ol>
    </footer>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
      const ALIASED_MAX = 1000;
      const COVERAGE_HEADERS = ["aCount", "cCount", "gCount", "tCount", "gapCount"];
      const GRAPH_MARGIN = { top: 20, right: 100, bottom: 50, left: 50 };
      const GRAPH_WIDTH = window.innerWidth * 0.9 - GRAPH_MARGIN.left - GRAPH_MARGIN.right;
      const GRAPH_HEIGHT = 250 - GRAPH_MARGIN.top - GRAPH_MARGIN.bottom;
      const ALIASED_GRAPH_HEIGHT = 100 - GRAPH_MARGIN.top - GRAPH_MARGIN.bottom;

      let coverageWindowStart = 0;
      let coverageWindowEnd = 1000;
      let coverageData = {};
      let globalMin = Number.MAX_SAFE_INTEGER;
      let globalMax = Number.MIN_SAFE_INTEGER;
      let usingExampleData = false;

      const parseCoverageData = (rawText, filename) => {
        const lines = rawText.split("\n");
        if (lines[lines.length - 1] === "") {
          lines.pop();
        }
        let minPos = Number.MAX_SAFE_INTEGER;
        let maxPos = Number.MIN_SAFE_INTEGER;
        let minCount = Number.MAX_SAFE_INTEGER;
        let maxCount = Number.MIN_SAFE_INTEGER;
        let globalCoverage = 0;
        const data = lines.slice(1).map((line) => {
          const [pos, aCount, cCount, gCount, tCount, gapCount, totalCount] = line.split("\t");
          const posInt = parseInt(pos);
          const totalCountInt = parseInt(totalCount);
          globalCoverage += totalCountInt;
          minPos = Math.min(minPos, posInt);
          maxPos = Math.max(maxPos, posInt);
          minCount = Math.min(minCount, totalCountInt);
          maxCount = Math.max(maxCount, totalCountInt);

          return {
            pos: posInt,
            aCount: parseInt(aCount),
            cCount: parseInt(cCount),
            gCount: parseInt(gCount),
            tCount: parseInt(tCount),
            gapCount: parseInt(gapCount),
            totalCount: totalCountInt,
          };
        });

        globalMin = Math.min(globalMin, minCount);
        globalMax = Math.max(globalMax, maxCount);
        globalCoverage = globalCoverage / (maxPos - minPos);

        let aliasedData;
        if (data.length < ALIASED_MAX) {
          aliasedData = data;
        } else {
          aliasedData = [];
          const aliasedDataIncrement = data.length / ALIASED_MAX;
          for (let i = 0; i < data.length; i += aliasedDataIncrement) {
            const chunk = data.slice(i, i + aliasedDataIncrement);
            const totalCount = chunk.reduce((acc, curr) => acc + curr.totalCount, 0) / aliasedDataIncrement;

            aliasedData.push({
              pos: Math.floor(i + aliasedDataIncrement / 2),
              totalCount,
            });
          }
        }

        const key = filename.replace(/[\W_]+/g, "-");

        coverageData[key] = {
          filename,
          data,
          aliasedData,
          minPos,
          maxPos,
          minCount,
          maxCount,
          globalCoverage,
        };

        createGraphs(key);
      };

      /**
       * Create a coverage graph for a given *.poscounts.tsv file. A stacked bar chart.
       */
      const createGraphs = (key) => {
        const data = coverageData[key].data.slice(coverageWindowStart, coverageWindowEnd);
        const maxPos = coverageData[key].maxPos;
        const minCount = coverageData[key].minCount;
        const maxCount = coverageData[key].maxCount;
        const globalCoverage = coverageData[key].globalCoverage.toFixed(2);

        let windowCoverage = 0;
        for (let i = 0; i < data.length; i++) {
          windowCoverage += data[i].totalCount;
        }
        windowCoverage = (windowCoverage / (coverageWindowEnd - coverageWindowStart)).toFixed(2);

        // Create container div (contains both graph and aliased graph)
        const containerDiv = document.createElement("div");
        containerDiv.id = "graph-container-" + key;
        containerDiv.style.cursor = "grab";
        containerDiv.classList.add("mb-5");

        const titleElement = document.createElement("h3");
        titleElement.classList.add("mt-5", "mb-4");
        titleElement.innerText = coverageData[key].filename;

        const downloadIcon = document.createElement("img");
        downloadIcon.classList.add("ms-2");
        downloadIcon.style.cursor = "pointer";
        downloadIcon.style.width = "2rem";
        downloadIcon.style.height = "2rem";
        downloadIcon.src = "download.png";
        addDownloadEventListener(downloadIcon, key, `-${coverageWindowStart}-${coverageWindowEnd}`);
        titleElement.appendChild(downloadIcon);

        const subtitleElement = document.createElement("h6");
        subtitleElement.innerText = `Total Counts: ${maxPos.toLocaleString()} | Global Coverage: ${globalCoverage}x | Window Coverage: ${windowCoverage}x`;

        document.getElementById("viz-container").appendChild(containerDiv);
        containerDiv.appendChild(titleElement);
        containerDiv.appendChild(subtitleElement);

        const toggleCoverageGraph = document.createElement("button");
        toggleCoverageGraph.classList.add("btn", "btn-outline-primary", "my-3");
        toggleCoverageGraph.innerText = "Toggle Window Coverage Graph";

        toggleCoverageGraph.addEventListener("click", () => {
          const graph = document.getElementById("graph-" + key);
          graph.classList.toggle("d-none");
        });

        containerDiv.appendChild(toggleCoverageGraph);
        createWindowCoverageGraph(key);
        createAliasedCoverageGraph(key);
      };

      const createWindowCoverageGraph = (key) => {
        const data = coverageData[key].data.slice(coverageWindowStart, coverageWindowEnd);
        const maxPos = coverageData[key].maxPos;
        const minCount = coverageData[key].minCount;
        const maxCount = coverageData[key].maxCount;

        // Create scales
        const x = d3.scaleLinear().domain([coverageWindowStart, coverageWindowEnd]).range([0, GRAPH_WIDTH]);
        const y = d3.scaleLinear().domain([minCount, maxCount]).range([GRAPH_HEIGHT, 0]);

        // Create color scale
        const color = d3.scaleOrdinal().domain(COVERAGE_HEADERS).range(d3.schemeCategory10);

        // Stack the data
        const stack = d3.stack().keys(COVERAGE_HEADERS).order(d3.stackOrderNone).offset(d3.stackOffsetNone);
        const stackedData = stack(data);

        // Create SVG
        const svg = d3
          .select(`#graph-container-${key}`)
          .append("div")
          .attr("class", "w-100")
          .append("svg")
          .attr("id", "graph-" + key)
          .attr("width", GRAPH_WIDTH + GRAPH_MARGIN.left + GRAPH_MARGIN.right)
          .attr("height", GRAPH_HEIGHT + GRAPH_MARGIN.top + GRAPH_MARGIN.bottom)
          .attr("font-family", "sans-serif")
          .classed("d-none", true)
          .append("g")
          .attr("transform", `translate(${GRAPH_MARGIN.left},${GRAPH_MARGIN.top})`);

        // Add axes
        svg.append("g").attr("transform", `translate(0,${GRAPH_HEIGHT})`).call(d3.axisBottom(x));
        svg.append("g").call(d3.axisLeft(y));

        // Add axes label
        svg
          .append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", 0 - GRAPH_MARGIN.left)
          .attr("x", 0 - GRAPH_HEIGHT / 2)
          .attr("dy", "1em")
          .style("font-size", "14px")
          .style("text-anchor", "middle")
          .text("Count");
        svg
          .append("text")
          .attr("transform", `translate(${GRAPH_WIDTH / 2},${GRAPH_HEIGHT + GRAPH_MARGIN.top})`)
          .attr("dy", "1em")
          .style("text-anchor", "middle")
          .style("font-size", "14px")
          .text("Position");

        // Create the bars
        svg
          .append("g")
          .selectAll("g")
          .data(stackedData)
          .enter()
          .append("g")
          .attr("fill", (d) => color(d.key))
          .selectAll("rect")
          .data((d) => d)
          .enter()
          .append("rect")
          .attr("x", (d) => x(d.data.pos))
          .attr("y", (d) => y(d[1]))
          .attr("height", (d) => y(d[0]) - y(d[1]))
          .attr("width", GRAPH_WIDTH / (coverageWindowEnd - coverageWindowStart));

        // Add legend
        const legend = svg
          .append("g")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "start")
          .selectAll("g")
          .data(COVERAGE_HEADERS)
          .enter()
          .append("g")
          .attr("transform", (d, i) => `translate(0,${i * 20})`);
        legend
          .append("rect")
          .attr("x", GRAPH_WIDTH + 10)
          .attr("width", 19)
          .attr("height", 19)
          .attr("fill", color);
        legend
          .append("text")
          .attr("x", GRAPH_WIDTH + 34)
          .attr("y", 9.5)
          .attr("dy", "0.32em")
          .text((d) => d);
      };

      const createAliasedCoverageGraph = (key) => {
        const data = coverageData[key].aliasedData;
        const maxPos = coverageData[key].maxPos;
        const minCount = coverageData[key].minCount;
        const maxCount = coverageData[key].maxCount;

        // Create scales
        const x = d3.scaleLinear().domain([0, maxPos]).range([0, GRAPH_WIDTH]);
        const y = d3.scaleLinear().domain([minCount, maxCount]).range([ALIASED_GRAPH_HEIGHT, 0]);

        // Create SVG
        const svg = d3
          .select(`#graph-container-${key}`)
          .append("div")
          .attr("class", "w-100")
          .append("svg")
          .attr("id", "aliased-graph-" + key)
          .attr("width", GRAPH_WIDTH + GRAPH_MARGIN.left + GRAPH_MARGIN.right)
          .attr("height", ALIASED_GRAPH_HEIGHT + GRAPH_MARGIN.top + GRAPH_MARGIN.bottom)
          .attr("font-family", "sans-serif")
          .append("g")
          .attr("transform", `translate(${GRAPH_MARGIN.left},${GRAPH_MARGIN.top})`);

        // Add axes
        svg.append("g").attr("transform", `translate(0,${ALIASED_GRAPH_HEIGHT})`).call(d3.axisBottom(x));
        svg.append("g").call(d3.axisLeft(y).tickSize(0).tickFormat(""));

        // Add axes label
        svg
          .append("text")
          .attr("transform", `translate(${GRAPH_WIDTH / 2},${ALIASED_GRAPH_HEIGHT + GRAPH_MARGIN.top})`)
          .attr("dy", "1em")
          .style("font-size", "14px")
          .style("text-anchor", "middle")
          .text("Position");

        // Create the bars
        svg
          .selectAll("rect")
          .data(data)
          .enter()
          .append("rect")
          .attr("x", (d) => x(d.pos))
          .attr("y", (d) => y(d.totalCount))
          .attr("height", (d) => y(minCount) - y(d.totalCount))
          .attr("width", GRAPH_WIDTH / data.length)
          .attr("fill", (d) => {
            return d.pos < coverageWindowStart || d.pos > coverageWindowEnd ? "lightgray" : "steelblue";
          });

        // Create two lines for coverage window
        svg
          .append("line")
          .attr("x1", x(coverageWindowStart))
          .attr("y1", y(minCount) + 5)
          .attr("x2", x(coverageWindowStart))
          .attr("y2", y(maxCount))
          .attr("stroke", "black")
          .attr("stroke-width", 2);

        svg
          .append("line")
          .attr("x1", x(coverageWindowEnd))
          .attr("y1", y(minCount) + 5)
          .attr("x2", x(coverageWindowEnd))
          .attr("y2", y(maxCount))
          .attr("stroke", "black")
          .attr("stroke-width", 2);
      };

      const getExampleData = async () => {
        const response = await fetch("example_output.zip");
        const data = await response.blob();
        const reader = new FileReader();
        reader.onload = async (e) => {
          const zip = new JSZip();
          const zipData = await zip.loadAsync(e.target.result);
          const files = Object.keys(zipData.files);

          for (const file of files) {
            if (!file.endsWith(".poscounts.tsv")) {
              continue;
            }
            const fileData = await zipData.file(file).async("string");
            parseCoverageData(fileData, file);
          }
        };

        reader.readAsArrayBuffer(data);
      };

      const addDownloadEventListener = (element, key, suffix) => {
        element.addEventListener("click", () => {
          downloadSVG("graph-" + key, suffix);
          downloadSVG("aliased-graph-" + key, suffix);
        });
      };

      const downloadSVG = (id, suffix) => {
        const svg = document.getElementById(id);
        const svgData = new XMLSerializer().serializeToString(svg);
        const blob = new Blob([svgData], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.setAttribute("href", url);
        a.setAttribute("download", id + suffix + ".svg");
        a.click();
        a.remove();
      };

      const container = document.getElementById("viz-container");
      const sortable = new Sortable(container, {
        animation: 200,
      });

      document.getElementById("input-folder").addEventListener("change", (e) => {
        const files = e.target.files;

        if (files.length === 0) {
          alert("No files selected.");
          return;
        }

        document.getElementById("use-example-data").classList.add("d-none");
        document.getElementById("coverage-container").classList.remove("d-none");

        const folderPath = files[0].webkitRelativePath.split("/")[0];
        document.getElementById("selected-folder-info").classList.remove("d-none");
        document.getElementById("selected-folder").innerText = folderPath;

        for (const file of files) {
          const relativePath = file.webkitRelativePath;
          const filename = file.name;
          const size = file.size;

          if (!filename.endsWith(".poscounts.tsv")) {
            continue;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            const rawText = e.target.result;

            parseCoverageData(rawText, filename);
          };

          reader.readAsText(file);
        }
      });

      document.getElementById("update-coverage-window").addEventListener("click", () => {
        coverageWindowStart = parseInt(document.getElementById("coverage-window-start").value);
        coverageWindowEnd = parseInt(document.getElementById("coverage-window-end").value);

        if (coverageWindowStart < 0 || coverageWindowEnd < 0 || coverageWindowStart >= coverageWindowEnd) {
          alert("Invalid coverage window. Please ensure start < end.");
          return;
        }

        document.getElementById("viz-container").innerHTML = "";
        for (const key in coverageData) {
          createGraphs(key);
        }
      });

      document.getElementById("use-example-data").addEventListener("click", () => {
        if (usingExampleData) {
          return;
        }

        document.getElementById("coverage-container").classList.remove("d-none");
        usingExampleData = true;
        const toggleButton = document.getElementById("use-example-data");
        toggleButton.innerText = "Using Example Data!";
        toggleButton.classList.remove("btn-warning");
        toggleButton.classList.add("btn-success");

        getExampleData();
      });

      document.getElementById("toggle-all-window-graphs").addEventListener("click", () => {
        let anyShown = false;
        for (const key in coverageData) {
          const graph = document.getElementById("graph-" + key);
          anyShown = anyShown || !graph.classList.contains("d-none");
        }

        for (const key in coverageData) {
          const graph = document.getElementById("graph-" + key);
          graph.classList.toggle("d-none", anyShown);
        }
      });
    </script>
  </body>
</html>
